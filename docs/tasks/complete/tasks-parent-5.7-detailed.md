# Subtask 5.7: Create output file with timestamp-based naming pattern

**Part of Parent Task 5.0: Build CLI Interface with Commander**

## Overview

Implement the final step of the document generation process: saving the generated document to a file with a timestamp-based naming pattern. This ensures unique filenames and prevents accidental overwrites while maintaining a clear naming convention.

## Implementation Steps

### 1. Create file naming utility

Create `src/utils/file-naming.ts`:

```typescript
import * as path from 'path';

/**
 * Generates a timestamp-based filename for the output document
 * Format: [document-type]-[YYYY-MM-DD-HHMMSS].md
 * Example: patent-assignment-2024-01-15-143052.md
 */
export function generateOutputFilename(documentType: string): string {
  const now = new Date();
  
  // Format: YYYY-MM-DD-HHMMSS
  const year = now.getFullYear();
  const month = String(now.getMonth() + 1).padStart(2, '0');
  const day = String(now.getDate()).padStart(2, '0');
  const hours = String(now.getHours()).padStart(2, '0');
  const minutes = String(now.getMinutes()).padStart(2, '0');
  const seconds = String(now.getSeconds()).padStart(2, '0');
  
  const timestamp = `${year}-${month}-${day}-${hours}${minutes}${seconds}`;
  
  return `${documentType}-${timestamp}.md`;
}

/**
 * Creates the full output path by combining directory and filename
 */
export function createOutputPath(outputDir: string, documentType: string): string {
  const filename = generateOutputFilename(documentType);
  return path.join(outputDir, filename);
}

/**
 * Extracts metadata from the filename for logging/display
 */
export function parseOutputFilename(filename: string): {
  documentType: string;
  timestamp: string;
} | null {
  const match = filename.match(/^(.+)-(\d{4}-\d{2}-\d{2}-\d{6})\.md$/);
  if (!match) {
    return null;
  }
  
  return {
    documentType: match[1],
    timestamp: match[2]
  };
}
```

### 2. Create file saving service

Create `src/services/file-writer.ts`:

```typescript
import { promises as fs } from 'fs';
import * as path from 'path';
import { logger } from '../utils/logger';

export interface SaveResult {
  path: string;
  size: number;
  timestamp: Date;
}

/**
 * Saves the generated document to the specified path
 */
export async function saveDocument(
  content: string,
  outputPath: string
): Promise<SaveResult> {
  logger.debug(`Attempting to save document to: ${outputPath}`);
  
  try {
    // Ensure the directory exists
    const dir = path.dirname(outputPath);
    await fs.mkdir(dir, { recursive: true });
    logger.debug(`Ensured directory exists: ${dir}`);
    
    // Write the file
    await fs.writeFile(outputPath, content, 'utf-8');
    logger.debug(`File written successfully`);
    
    // Get file stats
    const stats = await fs.stat(outputPath);
    logger.debug(`File size: ${stats.size} bytes`);
    
    return {
      path: outputPath,
      size: stats.size,
      timestamp: new Date()
    };
  } catch (error) {
    logger.error(`Failed to save document: ${error.message}`);
    throw new Error(`Failed to save document: ${error.message}`);
  }
}

/**
 * Adds metadata header to the document
 */
export function addDocumentMetadata(
  content: string,
  documentType: string,
  inputFile: string,
  generationTime: number
): string {
  const metadata = [
    '<!--',
    `Generated by CaseThread CLI POC`,
    `Document Type: ${documentType}`,
    `Input File: ${inputFile}`,
    `Generated: ${new Date().toISOString()}`,
    `Generation Time: ${generationTime}s`,
    '-->',
    '',
    ''
  ].join('\n');
  
  return metadata + content;
}
```

### 3. Update generate command to save files

Update `src/commands/generate.ts` to save the generated document:

```typescript
import { createOutputPath } from '../utils/file-naming';
import { saveDocument, addDocumentMetadata } from '../services/file-writer';

// Update the imports at the top
// ... existing imports ...

// Update the action handler
export const generateCommand = new Command('generate')
  .description('Generate a legal document from template and input data')
  .argument('<document-type>', 'Type of legal document to generate')
  .argument('<input-path>', 'Path to YAML input file')
  .option('-o, --output <path>', 'Output directory for generated document', '.')
  .option('-d, --debug', 'Enable debug logging')
  .action(async (documentType: string, inputPath: string, options: GenerateOptions) => {
    const spinner = new SpinnerWrapper(SPINNER_MESSAGES.INIT);
    const startTime = Date.now();
    
    try {
      // ... existing validation and generation code ...
      
      // After successful generation
      let generatedDocument;
      try {
        generatedDocument = await generateDocument(template, explanation, yamlData);
        clearInterval(updateInterval);
      } catch (error) {
        clearInterval(updateInterval);
        // ... error handling ...
      }
      
      // Step 6: Save the document
      spinner.updateMessage(SPINNER_MESSAGES.SAVE_DOC);
      
      // Calculate generation time
      const generationTime = Math.round((Date.now() - startTime) / 1000);
      
      // Add metadata to document
      const documentWithMetadata = addDocumentMetadata(
        generatedDocument,
        documentType,
        path.basename(inputPath),
        generationTime
      );
      
      // Create output path
      const outputPath = createOutputPath(outputDir, documentType);
      logger.debug(`Saving document to: ${outputPath}`);
      
      // Save the document
      const saveResult = await saveDocument(documentWithMetadata, outputPath);
      
      // Success!
      spinner.succeed(`${SPINNER_MESSAGES.SUCCESS} (completed in ${generationTime}s)`);
      
      // Display success information
      console.log('\n✨ Document Generation Complete!\n');
      console.log(`📄 Document Type: ${documentType}`);
      console.log(`📁 Saved to: ${saveResult.path}`);
      console.log(`📏 File size: ${(saveResult.size / 1024).toFixed(2)} KB`);
      console.log(`⏱️  Generation time: ${generationTime} seconds`);
      console.log('\n💡 Tip: You can open the file with: cat ' + saveResult.path);
      
      process.exit(ErrorCode.SUCCESS);
      
    } catch (error) {
      handleError(error as Error, spinner);
    }
  });
```

### 4. Create comprehensive tests

Create `__tests__/utils/file-naming.test.ts`:

```typescript
import { generateOutputFilename, createOutputPath, parseOutputFilename } from '../../src/utils/file-naming';

describe('File Naming Utilities', () => {
  beforeEach(() => {
    // Mock Date to ensure consistent timestamps
    jest.useFakeTimers();
    jest.setSystemTime(new Date('2024-01-15T14:30:52'));
  });

  afterEach(() => {
    jest.useRealTimers();
  });

  describe('generateOutputFilename', () => {
    it('should generate correct filename format', () => {
      const filename = generateOutputFilename('patent-assignment');
      expect(filename).toBe('patent-assignment-2024-01-15-143052.md');
    });

    it('should handle different document types', () => {
      expect(generateOutputFilename('nda-ip-specific')).toBe('nda-ip-specific-2024-01-15-143052.md');
      expect(generateOutputFilename('trademark-application')).toBe('trademark-application-2024-01-15-143052.md');
    });

    it('should pad single digits correctly', () => {
      jest.setSystemTime(new Date('2024-03-05T09:05:08'));
      const filename = generateOutputFilename('test-doc');
      expect(filename).toBe('test-doc-2024-03-05-090508.md');
    });
  });

  describe('createOutputPath', () => {
    it('should combine directory and filename correctly', () => {
      const outputPath = createOutputPath('/output/dir', 'patent-assignment');
      expect(outputPath).toBe('/output/dir/patent-assignment-2024-01-15-143052.md');
    });

    it('should handle relative paths', () => {
      const outputPath = createOutputPath('./output', 'test-doc');
      expect(outputPath).toBe('output/test-doc-2024-01-15-143052.md');
    });

    it('should handle current directory', () => {
      const outputPath = createOutputPath('.', 'test-doc');
      expect(outputPath).toBe('test-doc-2024-01-15-143052.md');
    });
  });

  describe('parseOutputFilename', () => {
    it('should parse valid filename', () => {
      const result = parseOutputFilename('patent-assignment-2024-01-15-143052.md');
      expect(result).toEqual({
        documentType: 'patent-assignment',
        timestamp: '2024-01-15-143052'
      });
    });

    it('should handle hyphenated document types', () => {
      const result = parseOutputFilename('nda-ip-specific-2024-01-15-143052.md');
      expect(result).toEqual({
        documentType: 'nda-ip-specific',
        timestamp: '2024-01-15-143052'
      });
    });

    it('should return null for invalid filenames', () => {
      expect(parseOutputFilename('invalid-filename.md')).toBeNull();
      expect(parseOutputFilename('test-2024-01-15.md')).toBeNull();
      expect(parseOutputFilename('test-doc-20240115-143052.md')).toBeNull();
    });
  });
});
```

Create `__tests__/services/file-writer.test.ts`:

```typescript
import { saveDocument, addDocumentMetadata } from '../../src/services/file-writer';
import { promises as fs } from 'fs';
import * as path from 'path';

jest.mock('fs/promises');

describe('File Writer Service', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe('saveDocument', () => {
    it('should save document successfully', async () => {
      const content = '# Test Document\n\nThis is a test.';
      const outputPath = '/output/test-doc.md';
      
      (fs.mkdir as jest.Mock).mockResolvedValue(undefined);
      (fs.writeFile as jest.Mock).mockResolvedValue(undefined);
      (fs.stat as jest.Mock).mockResolvedValue({ size: content.length });

      const result = await saveDocument(content, outputPath);

      expect(fs.mkdir).toHaveBeenCalledWith('/output', { recursive: true });
      expect(fs.writeFile).toHaveBeenCalledWith(outputPath, content, 'utf-8');
      expect(result).toMatchObject({
        path: outputPath,
        size: content.length
      });
    });

    it('should handle write errors', async () => {
      (fs.mkdir as jest.Mock).mockResolvedValue(undefined);
      (fs.writeFile as jest.Mock).mockRejectedValue(new Error('Permission denied'));

      await expect(saveDocument('content', '/readonly/file.md'))
        .rejects.toThrow('Failed to save document: Permission denied');
    });

    it('should handle directory creation errors', async () => {
      (fs.mkdir as jest.Mock).mockRejectedValue(new Error('Cannot create directory'));

      await expect(saveDocument('content', '/invalid/path/file.md'))
        .rejects.toThrow('Failed to save document: Cannot create directory');
    });
  });

  describe('addDocumentMetadata', () => {
    it('should add metadata header to document', () => {
      const content = '# Patent Assignment Agreement\n\nContent here...';
      const result = addDocumentMetadata(
        content,
        'patent-assignment',
        'input.yaml',
        45
      );

      expect(result).toContain('<!--');
      expect(result).toContain('Generated by CaseThread CLI POC');
      expect(result).toContain('Document Type: patent-assignment');
      expect(result).toContain('Input File: input.yaml');
      expect(result).toContain('Generation Time: 45s');
      expect(result).toContain('-->');
      expect(result).toContain(content);
    });

    it('should include ISO timestamp', () => {
      jest.useFakeTimers();
      jest.setSystemTime(new Date('2024-01-15T14:30:52Z'));

      const result = addDocumentMetadata('content', 'test', 'input.yaml', 30);
      
      expect(result).toContain('Generated: 2024-01-15T14:30:52.000Z');
      
      jest.useRealTimers();
    });
  });
});
```

Update `__tests__/commands/generate.test.ts` to test file saving:

```typescript
// Add file writer mocks
jest.mock('../../src/services/file-writer');
jest.mock('../../src/utils/file-naming');

import * as fileWriter from '../../src/services/file-writer';
import * as fileNaming from '../../src/utils/file-naming';

describe('Generate Command - File Saving', () => {
  beforeEach(() => {
    // ... existing setup ...
    
    // Setup file naming mocks
    (fileNaming.createOutputPath as jest.Mock).mockReturnValue('/output/patent-assignment-2024-01-15-143052.md');
    
    // Setup file writer mocks
    (fileWriter.addDocumentMetadata as jest.Mock).mockImplementation((content) => `<!-- metadata -->\n${content}`);
    (fileWriter.saveDocument as jest.Mock).mockResolvedValue({
      path: '/output/patent-assignment-2024-01-15-143052.md',
      size: 1024,
      timestamp: new Date()
    });
  });

  it('should save generated document with timestamp', async () => {
    // Setup all successful mocks
    (validator.isValidDocumentType as jest.Mock).mockReturnValue(true);
    (templateService.loadTemplate as jest.Mock).mockResolvedValue({});
    (templateService.loadExplanation as jest.Mock).mockResolvedValue('');
    (yamlService.parseYaml as jest.Mock).mockResolvedValue({});
    (openaiService.generateDocument as jest.Mock).mockResolvedValue('Generated document content');

    await generateCommand.parseAsync(['node', 'test', 'patent-assignment', 'test.yaml']);

    // Verify file naming
    expect(fileNaming.createOutputPath).toHaveBeenCalledWith(
      path.resolve('.'),
      'patent-assignment'
    );

    // Verify metadata added
    expect(fileWriter.addDocumentMetadata).toHaveBeenCalledWith(
      'Generated document content',
      'patent-assignment',
      'test.yaml',
      expect.any(Number)
    );

    // Verify document saved
    expect(fileWriter.saveDocument).toHaveBeenCalledWith(
      '<!-- metadata -->\nGenerated document content',
      '/output/patent-assignment-2024-01-15-143052.md'
    );

    // Verify success message
    expect(mockSpinner.succeed).toHaveBeenCalled();
  });

  it('should use custom output directory', async () => {
    // Setup mocks
    (validator.isValidDocumentType as jest.Mock).mockReturnValue(true);
    (templateService.loadTemplate as jest.Mock).mockResolvedValue({});
    (templateService.loadExplanation as jest.Mock).mockResolvedValue('');
    (yamlService.parseYaml as jest.Mock).mockResolvedValue({});
    (openaiService.generateDocument as jest.Mock).mockResolvedValue('Generated');

    await generateCommand.parseAsync([
      'node', 'test', 'patent-assignment', 'test.yaml',
      '--output', './my-docs'
    ]);

    expect(fileNaming.createOutputPath).toHaveBeenCalledWith(
      path.resolve('./my-docs'),
      'patent-assignment'
    );
  });

  it('should display success information', async () => {
    const consoleLogSpy = jest.spyOn(console, 'log').mockImplementation();

    // Setup mocks
    (validator.isValidDocumentType as jest.Mock).mockReturnValue(true);
    (templateService.loadTemplate as jest.Mock).mockResolvedValue({});
    (templateService.loadExplanation as jest.Mock).mockResolvedValue('');
    (yamlService.parseYaml as jest.Mock).mockResolvedValue({});
    (openaiService.generateDocument as jest.Mock).mockResolvedValue('Generated');

    await generateCommand.parseAsync(['node', 'test', 'patent-assignment', 'test.yaml']);

    expect(consoleLogSpy).toHaveBeenCalledWith(expect.stringContaining('✨ Document Generation Complete!'));
    expect(consoleLogSpy).toHaveBeenCalledWith(expect.stringContaining('📄 Document Type: patent-assignment'));
    expect(consoleLogSpy).toHaveBeenCalledWith(expect.stringContaining('📁 Saved to:'));
    expect(consoleLogSpy).toHaveBeenCalledWith(expect.stringContaining('📏 File size:'));
    expect(consoleLogSpy).toHaveBeenCalledWith(expect.stringContaining('⏱️  Generation time:'));
  });

  it('should handle file save errors', async () => {
    // Setup mocks
    (validator.isValidDocumentType as jest.Mock).mockReturnValue(true);
    (templateService.loadTemplate as jest.Mock).mockResolvedValue({});
    (templateService.loadExplanation as jest.Mock).mockResolvedValue('');
    (yamlService.parseYaml as jest.Mock).mockResolvedValue({});
    (openaiService.generateDocument as jest.Mock).mockResolvedValue('Generated');
    (fileWriter.saveDocument as jest.Mock).mockRejectedValue(
      new Error('Failed to save document: Permission denied')
    );

    try {
      await generateCommand.parseAsync(['node', 'test', 'patent-assignment', 'test.yaml']);
      fail('Should have thrown');
    } catch (error) {
      expect(error.message).toContain('process.exit called with code 1');
    }

    expect(mockSpinner.fail).toHaveBeenCalled();
  });
});
```

### 5. Manual Testing Steps

```bash
# Inside Docker container
docker exec -it casethread-dev bash

# Build the project
npm run build

# Test basic file generation
node dist/index.js generate patent-assignment docs/testing/scenario-inputs/tfs-01-patent-assignment-founders.yaml
# Should create file like: patent-assignment-2024-01-15-143052.md

# Verify file was created
ls -la *.md
# Should show the generated file with timestamp

# Check file contents
head -20 patent-assignment-*.md
# Should show metadata header followed by document content

# Test custom output directory
mkdir -p output/legal-docs
node dist/index.js generate nda-ip-specific docs/testing/scenario-inputs/cil-01-patent-assignment.yaml --output ./output/legal-docs
# Should create file in output/legal-docs/

# Verify custom directory
ls -la output/legal-docs/
# Should show the generated file

# Test multiple generations (should create unique files)
node dist/index.js generate patent-assignment docs/testing/scenario-inputs/tfs-01-patent-assignment-founders.yaml
sleep 2
node dist/index.js generate patent-assignment docs/testing/scenario-inputs/tfs-01-patent-assignment-founders.yaml
# Should create two different files with different timestamps

# Test file size reporting
node dist/index.js generate patent-assignment docs/testing/scenario-inputs/tfs-01-patent-assignment-founders.yaml
# Should show file size in KB

# Test read-only directory (should fail gracefully)
mkdir -p /tmp/readonly
chmod 444 /tmp/readonly
node dist/index.js generate patent-assignment test.yaml --output /tmp/readonly
# Should show permission error

# Run tests
npm test -- __tests__/utils/file-naming.test.ts
npm test -- __tests__/services/file-writer.test.ts
npm test -- __tests__/commands/generate.test.ts
```

## Common Pitfalls

1. **Timestamp precision**: Ensure timestamps are unique even for rapid generations
2. **Path handling**: Use path.join() for cross-platform compatibility
3. **File permissions**: Check write permissions before attempting to save
4. **Metadata encoding**: Ensure metadata doesn't break markdown parsing
5. **File size calculation**: Report in user-friendly units (KB, MB)

## Dependencies

- Node.js fs/promises for file operations
- Path module for cross-platform path handling
- Existing services and error handling

## Definition of Done

- [ ] Timestamp-based filename generation implemented
- [ ] Files saved with format: [type]-[YYYY-MM-DD-HHMMSS].md
- [ ] Metadata header added to documents
- [ ] Output directory respected from --output flag
- [ ] Success message shows file location and size
- [ ] File saving errors handled gracefully
- [ ] Unit tests cover all file operations
- [ ] Manual testing confirms files are created correctly
- [ ] No file overwrites with rapid generation
- [ ] Generation time included in metadata and output 